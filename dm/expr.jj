// options for generating parser
options {
  LOOKAHEAD=1;
}
//
PARSER_BEGIN(DTSExpression)
  package vista.dm;
  /**
    * An expression which has $(<DIGIT>)+ as relative references to rows
    * of pathname or dts name mappings in an MTS. These expressions are then
    * evaluated to a time series.
    *
    * The strategy for evaluating the resulting time series for the best trade
    * off of memory vs speed is to have a first pass thro' the expression and replace any
    * functions that require values of a time series from previous or future values to be
    * evaluated (e.g. period average, moving average, tidal average etcetra). Then a
    * single time series of the required timewindow is created and is filled in by evaluating
    * this modified expression by passing in values to it.
    * @author Nicky Sandhu
    * @version $Id: expr.jj,v 1.1 1999/11/03 01:20:20 nsandhu Exp $
    */
  public class DTSExpression {
    // needed for the factory version ! I didn't quite get to this
    public static NodeFactory factory = new DefaultNodeFactory();
  }
PARSER_END(DTSExpression)

SKIP : /* white space */
{
 	" "
|	"\r"
|	"\t"
}

TOKEN : /* end of line marker */
{
	< EOL: "\n" >
}

TOKEN : /* OPERATORS */
{
	< PLUS: "+" >
  |	< MINUS: "-" >
  |	< MULTIPLY: "*" >
  |	< DIVIDE: "/" >
  |	< EXP: "**" >
  |	< AND: "&" >
  |	< OR: "|" >
  |	< XOR: "^" >
  |	< LT: "<" >
  |	< GT: ">" >
  |	< GE: ">=" >
  |	< LE: "<=" >
  |	< EQ: "==" >
  |	< NE: "!=" >
}

TOKEN : /* numeric constants & relative reference */
{
	< CONSTANT: <FLOAT>
	    | <FLOAT> ( ["e","E"] ([ "-","+"])? <INTEGER> )?
    	>
  | 	< FLOAT: <INTEGER> 
	    | <INTEGER> ( "." <INTEGER> )?
	    | "." <INTEGER>
    	>
  | 	< INTEGER: ( <DIGIT> )+ >
  | 	< #DIGIT: ["0" - "9"] >
  |   < VARIABLE: "$" ( <DIGIT> )+ >
  |   < QUOTED_LITERAL: "'" (~["'"] | "\\'")* "'">
}

TOKEN:
{
  <INTERVAL: "15min"|"30min"|"1hour"|"1day"|"1mon" >
}

TOKEN : /* Function names */
{
	< ID: ( <LETTER> )+ ( <DIGIT> | <LETTER> )* >
  | 	< #LETTER: ["a"-"z", "A"-"Z"] > 
} 
// start symbol, the single line expression
void one_line() :
{}
{
  logical() <EOF>
}
// 
void logical() :
{}
{
    relational() (( <AND> | <OR> | <XOR> ) relational())*
}

void relational():
{}
{
  sum() (( <LT> | <GT> | <GE> | <LE> | <EQ> | <NE> ) sum())?
}
void sum() :
{}
{
  term() (( <PLUS> | <MINUS> ) term())*
}

void term() :
{}
{
    exp() (( <MULTIPLY> | <DIVIDE> ) exp())*
}

void exp() :
{}
{
    unary() ( LOOKAHEAD( <EXP> ) <EXP> exp() )*
}

void unary() :
{}
{
    <MINUS> element()
    | element()
}
// element is a constant, a relative reference variable, a function or another logical 
void element() :
{}
{
  <CONSTANT>
     | <VARIABLE>
     |  function()
     |  "(" logical() ")"
}
/* function is a name followed by a tuple of values.
void period_function() :
{}
{
  ("peravg"|"permax"|"permin") "(" logical() "," <QUOTED_LITERAL> ")"
    | "movavg" "(" logical() "," ["-"] <INTEGER> "," ["-"] <INTEGER> ")"
    | "tidalavg" "(" logical() ")"
    | "abs" "(" logical() ")"
    | "acc" "(" logical() ")"
}
*/
// function is a name followed by a tuple of values.
void function() :
{}
{
    <ID> "(" [ logical() ( "," ( logical() | <INTERVAL> ) )* ] ")"
}

